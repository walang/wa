; Wa builtin function, macro and core libraries.

(xdef eval wa-eval)
(xdef apply)
(xdef cons)
(xdef car)
(xdef cdr)
(xdef caar)
(xdef cadr)
(xdef cddr)
(xdef copylist copy-list)
(xdef list)
(xdef cons? consp)
(xdef atom)
(xdef no not)
(xdef ssyntax? ssyntaxp)
(xdef ssexpand expand-ssyntax)
(xdef annotate tag)
(xdef even? evenp)
(xdef odd? oddp)


(xdef err (&rest args)
  (error "~{~a~^:~@{ ~a~^~}~}" args))

(assign do (annotate 'mac
             (fn args `((fn () ,@args)))))

; TODO: safeset, sig
(assign mac (annotate 'mac
              (fn (name parms . body)
                `(assign ,name (annotate 'mac (fn ,parms ,@body))))))

; TODO: safeset, sig
(mac def (name parms . body)
  `(assign ,name (fn ,parms ,@body)))

(def map1 (f xs)
  (if (no xs)
      nil
      (cons (f (car xs)) (map1 f (cdr xs)))))

(def pair (xs (o f list))
  (if (no xs)
      nil
      (no (cdr xs))
      (list (list (car xs)))
      (cons (f (car xs) (cadr xs))
            (pair (cddr xs) f))))

(mac with (parms . body)
  `((fn ,(map1 car (pair parms))
      ,@body)
      ,@(map1 cadr (pair parms))))

(mac let (var val . body)
  `(with (,var ,val) ,@body))

(mac withs (parms . body)
  (if (no parms)
      `(do ,@body)
      `(let ,(car parms) ,(cadr parms)
         (withs ,(cddr parms) ,@body))))

; TODO:
(assign uniq (cl #'wa-gensym))
;(assign uniq (cl #'gensym))

(mac w/uniq (names . body)
  (if (cons? names)
      `(with ,(apply + nil (map1 (fn (n) (list n '(uniq)))
                             names))
         ,@body)
      `(let ,names (uniq) ,@body)))


(mac and args
  (if args
      (if (cdr args)
          `(if ,(car args) (and ,@(cdr args)))
          (car args))
      t))

(mac or args
  (and args
       (w/uniq g
         `(let ,g ,(car args)
            (if ,g ,g (or ,@(cdr args)))))))

(mac nor args
  `(no (or ,@args)))


; TODO: impl by wa
(def is (val . vals)
  (cl (flet ((f (x y)
               (or (and (numberp x) (numberp y) (= x y))
                   (eql x y)
                   (and (stringp x) (stringp y) (string= x y)))))
        (every (lambda (_) (f val _)) vals))))

(def isnt (x y)
  (no (is x y)))

(def iso (x y)
  (or (is x y)
      (and (cons? x)
           (cons? y)
           (iso (car x) (car y))
           (iso (cdr x) (cdr y)))))

(mac when (test . body)
  `(if ,test (do ,@body)))

(mac unless (test . body)
  `(if (no ,test) (do ,@body)))

(xdef stdout *standard-output*)
(xdef stdin *standard-input*)
(xdef stderr *error-output*)

(xdef infile (name)
  (open name :direction :input))

(xdef outfile (name)
  (open name :direction :output
             :if-exists :supersede
             :if-does-not-exist :create))

(xdef instring make-string-input-stream)
(xdef outstring make-string-output-stream)
(xdef inside get-output-stream-string)

(xdef call-w/stdout (output-port thunk)
  (with-open-stream (*standard-output* output-port)
    (funcall thunk)))

(xdef call-w/stdin (input-port thunk)
  (with-open-stream (*standard-input* input-port)
    (funcall thunk)))

(xdef readc (&optional (input-port *standard-input*))
  (read-char input-port nil nil nil))

(xdef readb (&optional (input-port *standard-input*))
  (read-byte input-port nil nil))

(xdef peekc (&optional (input-port *standard-output*))
  (peek-char nil input-port nil nil nil))

(xdef writec write-char)

(xdef writeb (i)
  (write-byte i *standard-output*))

(xdef write prin1)

(xdef disp princ)

(xdef sread (p eof)
  (let ((expr (read p nil eof)))
    (if (eq eof expr) eof expr)))

(xdef pr (&rest args)
  (format t "~{~A~}" args))

(xdef prn (&rest args)
  (format t "~{~A~}~%" args))

; XXX
(xdef + (&rest args)
  (if (not args)
      0
      (etypecase (car args)
        (number (apply #'+ args))
        (list   (apply #'append args))
        (t      (format nil "~{~@[~a~]~}" args)))))


; XXX
(cl (defun pairwise (pred lst)
      (loop for x in lst
            for y in (cdr lst)
            always (funcall pred x y))))

; XXX
(xdef > (&rest args)
  (etypecase (car args)
    (number    (apply #'> args))
    (string    (pairwise #'string> args))
    (symbol    (pairwise #'string> args))
    (character (pairwise #'char> args))
    (t         (apply #'> args))))

; XXX
(xdef < (&rest args)
  (etypecase (car args)
    (number    (apply #'< args))
    (string    (pairwise #'string< args))
    (symbol    (pairwise #'string< args))
    (character (pairwise #'char< args))
    (t         (apply #'< args))))

; XXX
(xdef >= (&rest args)
  (etypecase (car args)
    (number    (apply #'>= args))
    (string    (pairwise #'string>= args))
    (symbol    (pairwise #'string>= args))
    (character (pairwise #'char>= args))
    (t         (apply #'>= args))))

; XXX
(xdef <= (&rest args)
  (etypecase (car args)
    (number    (apply #'<= args))
    (string    (pairwise #'string<= args))
    (symbol    (pairwise #'string<= args))
    (character (pairwise #'char<= args))
    (t         (apply #'<= args))))

(xdef exact integerp)


(xdef -)
(xdef *)
(xdef /)
(xdef mod)
(xdef expt)
(xdef sqrt)
(xdef sin)
(xdef cos)
(xdef tan)
(xdef asin)
(xdef acos)
(xdef atan)
(xdef log)

(xdef rand (&optional (n 1))
  (random n))

(xdef trunc (n)
  (values (truncate n)))

(xdef rep)

(xdef len (x)
  (etypecase x
    (sequence   (length x))
    (hash-table (hash-table-count x))))

(assign load (cl #'wa-load)) ; TODO: impl by wa

(def type (x)
  (cl (cond ((taggedp x) (tag-type x))
            ((consp x) 'cons)
            ((symbolp x) 'sym)
            ((functionp x) 'fn)
            ((characterp x) 'char)
            ((stringp x) 'string)
            ((integerp x) 'int)
            ((numberp x) 'num)
            ((hash-table-p x) 'table)
            ((output-stream-p x) 'output)
            ((input-stream-p x) 'input)
            ; TODO:
            ;((tcp-listener? x)  'socket)
            ;((thread? x)        'thread)
            ((typep x 'condition) 'exception)
            (t  (error "Type: unknown type: ~S" x)))))

(xdef newstring make-string)
(xdef newstr make-string)

(xdef quit exit)

(mac afn (parms . body)
  `(let self nil
     (assign self (fn ,parms ,@body))))

(xdef table ()
  (make-hash-table :test 'equal))

(xdef maptable maphash)

(xdef msec ()
  (* (sb-posix:time) 1000))

(xdef seconds ()
  (sb-posix:time))

;(xdef atomic-invoke (f)
;  (bt:with-recursive-lock-held (ar-the-lock)
;    (funcall f)))

(xdef flushout ()
  (force-output *standard-output*)
  t)

(xdef open-socket (num)
  (usocket:socket-listen "localhost"
                         num
                         :reuseaddress t
                         :element-type '(unsigned-byte 8)))

(xdef socket-accept (s)
  (usocket:socket-accept s))

;(xdef setuid (uid)
;  (sb-posix:setuid uid))

(xdef new-thread (f)
  (sb-thread:make-thread f))

(xdef kill-thread (th)
  (sb-thread:terminate-thread th))


;(xdef break-thread break-thread)

(xdef current-thread ()
  sb-thread:*current-thread*)

(xdef sleep)

(xdef system (cmd)
  (run-program "/bin/sh" (list "-c" cmd) :search t :output *standard-output*)
  nil)

(xdef pipe-from (cmd)
  (process-output (run-program "/bin/sh" (list "-c" cmd) :output :stream)))

(xdef protect (during after)
  (unwind-protect (funcall during)
    (funcall after)))

(xdef on-err (errfn f)
  (handler-case (funcall f)
    (error (e) (funcall errfn e))))

;(xdef on-err (errfn f)
;  (multiple-value-bind (ans cond) (ignore-errors (funcall f))
;    (or ans (funcall errfn cond))))

(xdef details (c)
  (format nil "~A" c))



;(mac = args
;  `(cl (progn  (setf ,@args))))


(mac compose args
  (let g (uniq)
    `(fn ,g
       ,((afn (fs)
           (if (cdr fs)
               (list (car fs) (self (cdr fs)))
               `(apply ,(if (car fs) (car fs) 'idfn) ,g)))
         args))))

(mac complement (f)
  (let g (uniq)
    `(fn ,g (no (apply ,f ,g)))))


(def orf fns
  (fn args
    ((afn (fs)
       (and fs (or (apply (car fs) args) (self (cdr fs)))))
     fns)))

(def andf fns
  (fn args
    ((afn (fs)
       (if (no fs)       t
           (no (cdr fs)) (apply (car fs) args)
                         (and (apply (car fs) args) (self (cdr fs)))))
     fns)))

(def empty (seq)
  (or (no seq)
      (and (or (is (type seq) 'string) (is (type seq) 'table))
           (is (len seq) 0))))

(def reclist (f xs)
  (and xs (or (f xs) (reclist f (cdr xs)))))

(def isa (x y) (is (type x) y))

(def testify (x)
  (if (isa x 'fn) x [is _ x]))

(xdef list? listp)

(def some (test seq)
  (let f (testify test)
    (if (list? seq)
        (reclist f:car seq)
        (recstring f:seq seq))))

(def all (test seq)
  (~some (complement (testify test)) seq))

(def map (f . seqs)
  (if (some [isa _ 'string] seqs)
       (withs (n   (apply min (map len seqs))
               new (newstring n))
         ((afn (i)
            (if (is i n)
                new
                (do (sref new (apply f (map [_ i] seqs)) i)
                    (self (+ i 1)))))
          0))
      (no (cdr seqs))
       (map1 f (car seqs))
      ((afn (seqs)
        (if (some no seqs)
            nil
            (cons (apply f (map1 car seqs))
                  (self (map1 cdr seqs)))))
       seqs)))
